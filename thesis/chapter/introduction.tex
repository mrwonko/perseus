%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EinfÃ¼hrung: Wichtigster Teil (zusammen mit Schluss) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Einleitung
\chapter{Introduction} %TODO name?

%TODO explain the language's name somewhere in this chapter
    
    \section{Target audience}
    This thesis is written under the assumption that the reader has a solid understanding of the basics of computer science.
    % TODO more detail?

	\section{Goal} %TODO better title?
	% Ziel
	% konkrete Zielsetzung; auch: was nicht?
	% TODO
	
	I have a concept for a programming language called Perseus. I envision a strongly typed scripting language with native serialization support for execution contexts, so a paused script can be saved and later resumed, possibly on a different computer.
	
	My goal for this thesis was to create prototypes of a compiler and a virtual machine implementing a small subset of it, mostly consisting of basic arithmetic and relational operations, functions and variables. Those prototypes can later be built upon to create a full-blown language, but that is outside of the scope of this thesis.
	
	The aim was for the following program to work -- as we shall see, I achieved that with the exception of one quirk.
	
	\lstperseus
	\begin{lstlisting}[caption={Desired target language example},label={lst:target_language}]
function fib( x : i32 ) -> i32
    // if the body is a single expression, no {}-block is required
    if x <= 1
        x
    else
        fib( x - 1 ) + fib( x - 2 )

impure function main()
{
	let index : i32 = 10;
	// variable types can be deduced from their initialization
	let result = fib( index );
	// print is an impure built-in function (i.e. it has side effects, in this case writing something), so main() needs to be impure as well to be able to call it
	print( result )
}
	\end{lstlisting}
	
	I will not go into much detail on the language itself in this thesis -- the focus is on the compiler and the virtual machine, not least because the language is still a work in progress.
    
    
	\section{Approach} %TODO better title
	% Beschreibung der Vorgehensweise -- wie soll Ziel erreicht werden? Welche Themen in welchen Kapiteln, warum? Prinzipielle Argumentationslinie? -> roten Faden deutlich machen
	
	After this introduction I start by recapitulating the necessary theory behind compilers and virtual machines and explaining the important software patterns used in my solution. I also look into the available technology before I go on to describe in detail the requirements -- what exactly are the compiler and the virtual machine supposed to do? Then I explain my design -- how I planned to fulfill those requirements -- followed by details on the implementation of said design. Finally I evaluate my results, comparing them to my plans.
	
	%TODO sufficient?
	
	\section{Why a new programming language?}
	% Motivation
	% Einordnung der Thesis in allgemeinen Problemkontext -- diesen dazu kurz beschreiben (ca. 1--2 Seiten)
	
	There are plenty of programming languages to choose from -- why would I want yet another one? In short because I have yet to find one that satisfies all my requirements: I want a safe powerful strongly typed scripting language with elements from functional and object-oriented programming languages that has coroutines which can be serialized to a cross-platform binary format to be later resumed, possibly on a different computer. It should be easy to embed in C++ applications, have no garbage collection and avoid null- and dangling pointers.
	
	AngelScript\cite{angelscript} is an example of a statically typed scripting languages for embedding in C++, but it doesn't have coroutines that can be serialized, has null-pointers and it's type system is not powerful enough, lacking generic types. And while Lua\cite{lua}, which embeds nicely in C, has coroutines that can be serialized using Pluto\cite{pluto}, it is dynamically typed and uses garbage collection. Rust\cite{rust} has a lot of what I'm looking for, serialization aside, but it's no scripting language.
	
	So since I know of no such language, I've decided to work on one myself.
	
	\section{Why a new virtual machine?}
	
	To compile a new language I need a new compiler. But do I also need a custom byte code and a custom virtual machine to run it? Why can't I target an existing virtual machine or native machine code?
	
	Again it boils down to existing solutions not satisfying all my requirements, in particular coroutine support and absence of garbage collection. For a more detailed analysis refer to the ``Requirements'' chapter.
	
	%TODO is it really the requirements chapter?
