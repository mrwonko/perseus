% Lösung bzgl. Zielsetzung -- Bezug zu methodischem Teil herstellen

% (Ist-Analyse)
\chapter{State of the art}
	
	% immer erwähnen, was man nutzt, und nie nur das
	
	This chapter examines noteworthy compiler generators as well as virtual machines
	%TODO and programming languages
	that influenced the design of the Perseus
	%TODO language and
	VM.
	
	\section{Common Compiler Generators}
    	
		Lexers and parsers are rarely hand-written any more, since there are plenty of tools to generate them using formal definitions. Let's compare some free and open source examples that can target C/C++ representing different approaches.
		
		First of all there's flex\cite{flex}, a classic lexer generator that creates C code from a definition file describing the tokens using regular expressions and code to be executed upon their recognition, for example suspending scanning and returning a token. The generated C source code is then compiled to get an executable lexer. flex is often used together with bison.
		
		bison\cite{bison} generates various kinds of LR parsers in C, C++ and Java from a definition file describing the context-free grammar to be accepted. The generated source code is then compiled to get an executable parser.
		
		Boost.Spirit\cite{spirit} is a C++ parser and lexer library. (It also has a module for generator definitions, but that is of no interest here.) It's different from flex and bison (and most other compiler generators) in that it doesn't have a separate generation step; the definitions are made in standard C++.
		
		Boost.Spirit.Lex, the lexer component, lets you define the tokens using strings containing regular expressions. These are parsed and used to generate a deterministic finite automaton at run time, which has the downside that the computations will be repeated at each execution and syntactic errors in the regular expressions can't be detected during compilation. To offset this there's the option to generate equivalent static C++ source code for the calculated automaton on execution, which can then be used in place of the run time version for improved performance. Besides requiring no external tools for compilation it's also very easy to integrate with Boost.Spirit.Qi.
		
		Boost.Spirit.Qi is the parser component. Making heavy use of templates it allows for the definition of a parsing expression grammar using overloaded operators, creating a recursive descent parser. It eschews the packrat algorithm in favor of simple backtracking.

	\section{Common Virtual Machines}
		% Stand der Technik, insb. bzgl. VMs / Einordnung
		
		There are numerous virtual machines a compiler may target. One common example is the Java Virtual Machine (JVM), which was initially created for Java, but has since been targeted by other languages as well. It is stack-based and uses garbage collection to manage its memory.
		
		Another example, the LLVM is not just a virtual machine. It defines an Intermediate Representation for program code that compilers can target, much like byte code. It is then capable of optimizing it, compiling it to various machine code formats or executing it using on-demand compilation (JIT/Just In Time). It is register-based and supports both manual memory management and garbage collection, but no coroutines.
	
	%TODO \section{Selected Programming Languages}

% Anforderungsanalyse / Requirements
\chapter{Requirements}\label{requirements}

	%TODO where does this go? requirements? 
	%Native machine code would require porting work for each new platform. By using a virtual machine, any platform that's capable of running it is supported. My virtual machine requirements are mainly support for coroutines and stack inspection/unwinding, so coroutines can be serialized and aborted properly, and the ability to embed it in C++.
	
	This chapter lays down the precise requirements for the compiler and the VM in the context of this thesis. Notably this includes the initial features of Perseus, the language to be compiled. It also explains why existing VMs don't fulfill these requirements, motivating the creation of a custom VM.

    \section{Target Language}
    
    	Eventually Perseus will be used as an embedded language, supplied as a library with functions to compile Perseus source code and execute functions in it. Initially that doesn't matter as much, just having some environment to execute Perseus scripts in is currently sufficient.
    	
    	The syntax should generally be based on Rust\cite{rust}, though only roughly; differences are acceptable. With that in mind, the following is what the language should be capable of initially.
    	
    	\subsection{Initial Feature-Set}
    	
			A Perseus program is made up of function definitions, one of which is called \lstinline$main()$ and is the entry point, for the time being. It has no parameters, but generally functions can have them and may be overloaded on them. The number and types of parameters are fixed, and functions are annotated with whether they are pure, i.e. side-effect free. Pure functions may only call other pure functions.
			
			Perseus scripts can also call native functions which have previously been registered. As a proof of concept an impure \lstinline$print(value)$ function will suffice initially; as the name suggests, it writes its single parameter to the standard output.
			
			To document Perseus scripts single- and multiline comments can be used. Multiline comments need not support nesting.
			
			The types initially supported are \lstinline$i32$, a 32 bit signed integer type, and \lstinline$bool$, a boolean type stored as a character since that is the smallest addressable unit. There's also a void type, \lstinline$()$, for statements. Arrays and record types are not initially supported, but will be added at a later time.
	    	
	    	The simplest expressions are literals: Constant values written directly the code. Integer literals can be written in decimal (default), hexadecimal (prefix \lstinline$0x$) or binary (prefix \lstinline$0b$), with the option of using \lstinline$'$ as a separator, as in \lstinline$1'000'000$ or \lstinline$0b0010'1010$. Boolean literals are \lstinline$true$ and \lstinline$false$.
	    	
	    	Expressions can be combined using operators. In the future users will be able to define their own operators, including their associativity and precedence, so those should not be defined through the grammar but resolved at a later time. The predefined operators are given in table \ref{tab:perseus_operators}. Operators of same precedence with no associativity need explicit parentheses -- e.g. \lstinline$a==b==c$ is illegal.
	    	
	    	\begin{table}
			\begin{center}
			\begin{tabular}{ l l l l l }
			\toprule
			Symbol & Operands & Associativity & Precedence & Name \\
			\midrule
			\lstinline$*$ & \lstinline$i32, i32$ & left & 7 & integer multiplication \\
			\lstinline$/$ & \lstinline$i32, i32$ & left & 7 & integer division \\
			\lstinline$%$ & \lstinline$i32, i32$ & left & 7 & integer modulo \\
			\lstinline$+$ & \lstinline$i32, i32$ & left & 6 & integer addition \\
			\lstinline$-$ & \lstinline$i32, i32$ & left & 6 & integer subtraction \\
			
			\lstinline$==$ & \lstinline$i32, i32$ & none & 4 & integer equality \\
			\lstinline$!=$ & \lstinline$i32, i32$ & none & 4 & integer inequality \\
			\lstinline$<$  & \lstinline$i32, i32$ & none & 4 & less than \\
			\lstinline$<=$ & \lstinline$i32, i32$ & none & 4 & less than or equals \\
			\lstinline$>$  & \lstinline$i32, i32$ & none & 4 & greater than \\
			\lstinline$>=$ & \lstinline$i32, i32$ & none & 4 & greater than or equals \\
			
			\lstinline$==$ & \lstinline$bool, bool$ & none  & 4 & boolean equality \\
			\lstinline$!=$ & \lstinline$bool, bool$ & none  & 4 & boolean inequality \\
			\lstinline$&&$ & \lstinline$bool, bool$ & right & 3 & boolean and \\
			\lstinline$||$ & \lstinline$bool, bool$ & right & 2 & boolean or \\
			
			\lstinline$-$ & \lstinline$i32$  & & & integer negation \\
			\lstinline$!$ & \lstinline$bool$ & & & boolean negation \\
			\bottomrule
			\end{tabular}
			\caption{Predefined operators}\label{tab:perseus_operators}
			\end{center}
			\end{table}
			
			In the absence of error handling divide by zero currently leads to termination of the execution. There is no short-circuit evaluation for \lstinline$&&$ and \lstinline$||$\footnote{The absence of short-circuit evaluation means both operands are always evaluated, even if evaluating the left one suffices to determine the result.}. (For simplicity's sake; this may change in the future.)
			
			``Block'' expressions contain multiple expressions to be executed serially; they may include variable definitions, which must include the initial value; its type can optionally be deduced from this. A variable is usable until the end of the block it was defined in. A block evaluates to the last expression in it.
			
			``If'' expressions evaluate to either their ``then'' expression or their ``else'' expression, depending on their condition, so both of those must have the same type. If the ``then'' expression is of type void, the ``else'' expression can be omitted.
        
        \subsection{Future features}
        	
        	Some future features should be kept in mind during implementation to ease their future addition. Besides the aforementioned user-defined types and operators, these are as follows:
        	
        	A UTF-32 string type. String literals will be UTF-8 encoded; scripts may therefore start with a UTF-8 Byte Order Mark\footnote{A special UTF-8 character signifying that the file in question is encoded in UTF-8.}.
        	
        	Coroutine support. %TODO say more here?
        	
        	Pointer types of some sort. Regardless of how exactly they look syntactically, there will at some point be a way to reference memory locations. This includes both the heap -- there will also be dynamic memory at some point -- and the stacks -- plural, since there's one for each coroutine.
        	
        	Serialization. There will be built-in support for serialization, with type annotations of some kind. Critically this will also include the ability to serialize paused coroutines (if the variables on their stack are serializable) so they can be resumed at a later date, possibly on a different computer. The use-case is a video game using Perseus scripts for its logic while allowing the player to save at any time, at which point a running script may need to be saved as well.
            
	
	\section{Compiler}
		
		The compiler is responsible for compiling Perseus scripts (as described above) into executable byte code for the VM. The input can be a file or a string from memory.
		
		It is important that the compiler tracks the current file location (at least the line, possibly also the column) so that error messages can include a location. It is acceptable for compilation to stop at the first error.
	
	\section{VM}
	
		The compiled byte code is run by a virtual machine so it can easily be executed on different machines.
		
		This VM needs to allow for manual memory management, since that will be added to Perseus in the future; it must not require garbage collection of dynamic memory.
		
		It also needs to support coroutines. While not part of this thesis they too will be added to the language at a later point, so the VM must not prohibit that.
		
		And lastly it must allow for stack inspection so coroutines can be serialized and safely aborted. Serialization will be one of the main features of Perseus in the future, so it's imperative that it can be implemented.
		
		\subsection{Suitability of existing VMs}
		
			I am not aware of any mainstream VMs that fulfill these requirements. The JVM and the Common Language Runtime\footnote{The VM targeted by C\#} are unsuitable because they force the use of garbage collection, while LLVM has no support for coroutines.

\chapter{Design} %TODO better name?
% Ansatz, d.h. z.B. Architektur, Module und ihre Kommunikation

What is this chapter? %TODO

	\section{Choice of implementation language}
		\subsection{Why C++?}
		\subsection{Why C++14?}
		%why MSVC2015RC?
	
	\section{Choice of libraries}
		\subsection{Why Boost.Spirit?}
			no separate generation step, uses C++ templates instead (at the cost of compile time - lots of it)
			
			header-only
			
			recursive descent parser $\rightarrow$ no left recursions
			\subsubsection{Choice of version}
				why v2 and not x3?
				
				released May 15th
				
				see http://boost-spirit.com/home/2015/05/16/spirit-3-0-0/
		\subsection{Why Boost.Test?}
	
	% TODO: should I talk about coding standards at all?
	
	\section{Opcodes}
	
	
	% Namespaces - perseus / perseus::detail
	% Generally: why bytecode?
	\section{Modules}
	
		% I suppose a diagram would be useful here?
		
		\subsection{Compiler}
		
			\subsubsection{Lexer}
			Line numbers for error messages (\& Token attributes vs iterator ranges)
			
			utf-32 input preprocessing and how Spirit doesn't like that, but how it's only of interest in string literals anyway
			
			\subsubsection{Parser}
			
			\subsubsection{Code Generation}
			
			\subsection{Virtual Machines}
			
			Error handling - C++ exceptions etc.
			
			Why are pointers stack-relative?
			
			Why little metadata on stack? (except RTTI for yielding)
			
			%TODO how will serialization be realized one day?
			
			\subsubsection{code segment}
				opcode encoding
			\subsubsection{coroutine}
			\subsubsection{stack}
			\subsubsection{processor}
		
		\subsection{Unit Tests}
		

% Entwicklungsanalyse
\chapter{Implementation}

	% Umsetzung wesentlicher Module, ggf. Quellcode-Ebene
	What is this chapter? %TODO
	
	\section{Coming to terms with Boost}
	
		Trouble finding information in the documentation -- it's there, just hard to find.
		
		Accidental left-recursion leading to infinite loops, resulting in stack overflows.
	
	\section{Grammar definition}
	
		Sourcecode sample: this is what the definition looks like.
		
		Here's how the results are combined to create the syntax tree.
		
		Explain expectations.
		
		Operation-List in lieu of left-recursion, and how that needs to be post-processed to take care of precedences. And why those are not coded into the grammar. And how it also contains calls and indexing, making the lack of precedence resolution slightly more awkward.
	
	\section{Types}
	
		Represented as enum, only int, bool and void.
	
	\section{Function Manager}
	
		%Iterators to entries in AST, how that crashed for no apparent reason, how I'm now using pointers and unhappy about it but how it's just as legal.
		
		\subsection{Iterator Bug}
		
			is it of any interest to talk about a compiler bug I stumbled upon, couldn't quite identify (and thus did not know if it actually was a bug in the compiler and not in my code), and worked around, but that disappeared upon compiler update?
	
	\section{Code Generation}
	
		transformation from parser tree into clean tree
		
		placeholders for jump offsets
	
	\section{Code Segment}
		
		opcode encoding/decoding
	
	\section{Opcode documentation}
	
	\section{Virtual Machine}
	
		switch-statement for opcode execution
		
		\subsection{Aggregate return bug}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Schluss: Wichtigster Teil (zusammen mit Einführung) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluating the results}
% Zusammenfassung
% What did I achieve?
% Ergebnisse zusammenfassen, bewerten bzgl. Zielsetzung, Perspektiven
% lessons learned
This chapter examines the resulting compiler and VM: Do they fulfill the requirements? What does a Perseus program look like and how does the compiler translate it into executable byte code?

The goal was mostly reached: A small core of Perseus can be compiled and executed. Compared to the desired target language example (Listing~\ref{lst:target_language}), this is what the actual syntax looks like:

\begin{perseuslisting}[caption={Actual resulting language example},label={lst:result_language}]
function fib( x : i32 ) -> i32
    if x <= 1
        x
    else
    	// precedence must be explicitly defined since function calls are syntactically treated similar to binary operators and operator precedence is not resolved yet.
        ( fib( x - 1 ) ) + ( fib( x - 2 ) )

impure function main()
{
	let index : i32 = 10;
	let result = fib( index );
	print( result )
}
\end{perseuslisting}

That's pretty much on target, sans operator precedence resolution. The error messages for invalid code still leave a lot to be desired though -- they often lack information on the location of the problem. It's technically possible to include this information, and it sometimes is included already, but it was no priority during initial development, so future work in this area is required.

Meanwhile the virtual machine already has support for coroutines in anticipation for their future addition to the language. New opcodes, e.g. for unsigned integer and floating point arithmetic, are easy to add. The main challenge in extending it will probably be the addition of stack inspection and unwinding.

One of the main difficulties during development was figuring out how exactly to use certain features of Boost.Spirit, the compiler generator used. It eventually did its job, removing an additional compiler generation step from the build process as intended; and by taking advantage of C++'s powerful static type system most errors could be caught at compile time.

Due to the usage of the latest C++14 features on a preview release of the Microsoft Visual C++ Compiler, a couple of compiler bugs were encountered, but its usage was still justified in that it made writing fast, correct and elegant code noticeably easier than it would have been in C++98. The compiler has since had its full release, which fixed all the bugs that had been encountered.


\section{Resulting translation by example}

Taking listing \ref{lst:result_language} as an example, what do the steps of compilation look like? First, the lexer turns the source code into the following token stream (whitespaces and comments are omitted in this listing for brevity, and some indentation was added to aid comprehension):

\begin{codelisting}[caption="Abridged tokens of listing \ref{lst:result_language}"]
"function", identifier(fib), "(", identifier(x), ":", identifier(i32), ")", "->", identifier(i32),
    "if", identifier(x), operator(<=), decimal literal(1),
        identifier(x),
    "else",
        "(", identifier(fib), "(", identifier(x), operator(-), decimal literal(1), ")", ")", operator(+), "(", identifier(fib), "(", identifier(x), operator(-), decimal literal(2), ")", ")"

"impure", "function", identifier(main), "(", ")",
"{"
    "let", identifier(index), ":", identifier(i32), "=", decimal literal(10), ";"
    "let", identifier(result), "=", identifier(fib), "(", identifier(index), ")", ";"
    identifier(print), "(", identifier(result), ")",
"}"
\end{codelisting}

The parser builds the syntax tree shown in figure \ref{fig:result_language_parser_tree} from these tokens. This syntax tree is then transformed in various ways: Expressions are rearranged, variable references resolved, types checked etc. The result is the transformed syntax tree shown in figure \ref{fig:result_language_transformed_tree}. Based on that byte code is generated -- listing \ref{lst:result_bytecode} shows the generated ``fib'' function in humanly readable format.

\begin{figure}
\centering
\begin{forest}
[\textit{file}
	[{fib() $\rightarrow$ i32}
		[\textit{arguments}
			[{x : i32}]
		]
		[\textit{expression}
			[\textit{operand}
				[\textit{if}
					% x <= 1
					[\textit{expression}
						[\textit{operand}
							[x]
						]
						[\textit{operations}
							[{$<=$}
								[{$1$}]
							]
						]
					]
					% x
					[\textit{expression}
						[\textit{operand}
							[x]
						]
					]
					% fib(x-1) + fib(x-2)
					[\textit{expression}
						[\textit{operand}
							% fib(x-1)
							[\textit{expression}
								[\textit{operand}
									[fib]
								]
								[\textit{operations}
									[\textit{call}
										[\textit{expression}
											[\textit{operand}
												[x]
											]
											[\textit{operations}
												[{$-$}
													[{$1$}]
												]
											]
										]
									]
								]
							]
						]
						[\textit{operations}
							[{$+$}
								% fib(x-2)
								[\textit{expression}
									[\textit{operand}
										[fib]
									]
									[\textit{operations}
										[\textit{call}
											[\textit{expression}
												[\textit{operand}
													[x]
												]
												[\textit{operations}
													[{$-$}
														[{$2$}]
													]
												]
											]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]
	[{main() $\rightarrow$ ()}
		[{[omitted for brevity]}]
	]
]
\end{forest}
\caption{Abridged syntax tree of listing \ref{lst:result_language}}
\label{fig:result_language_parser_tree}
\end{figure}

\begin{figure}
\centering
\begin{forest}
[\textit{file}
	[{fib() $\rightarrow$ i32}
		[\textit{expression}
			[\textit{if}
				[\textit{expression} : bool
					[{$<=$}
						[\textit{expression}
							[i32 var at -8]
						]
						[\textit{expression}
							[$1$]
						]
					]
				]
				[\textit{expression}
					[i32 var at -8]
				]
				[\textit{expression}
					[{$+$}
						[\textit{expression}
							[fib()
								[\textit{expression}
									[{$-$}
										[\textit{expression}
											[i32 var at -12]
										]
										[\textit{expression}
											[$1$]
										]
									]
								]
							]
						]
						[\textit{expression}
							[fib()
								[\textit{expression}
									[{$-$}
										[\textit{expression}
											[i32 var at -16]
										]
										[\textit{expression}
											[$2$]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]
	[{main() $\rightarrow$ ()}
		[{[omitted for brevity]}]
	]
]
\end{forest}
\caption{Abridged transformed syntax tree of listing \ref{lst:result_language}}
\label{fig:result_language_transformed_tree}
\end{figure}

\begin{codelisting}[caption="Byte code translation of function fib() in listing \ref{lst:result_language}",label={lst:result_bytecode}]
; this byte code for fib() starts at address 26
relative_load_stack size=4 offset=-8
push_32 value=1
less_than_or_equals_i32
; if
relative_jump_if_false offset=14
; then
	relative_load_stack size=4 offset=-8
	relative_jump offset=51
; else
	reserve size=4
	relative_load_stack size=4 offset=-12
	push_32 value=1
	subtract_i32
	call address=26 ; recursive call
	reserve size=4
	relative_load_stack size=4 offset=-16
	push_32 value=2
	subtract_i32
	call address=26 ; recursive call
	add_i32
relative_store_stack size=4 offset=-16
pop size=4
return parameter_size=4
\end{codelisting}

\chapter{Future prospects}
% Ausblick
%*  [Future plans/possibilities]
This chapter details possible future changes to the compiler and VM, explaining how the Perseus language might change.

As mentioned only a very simple core of the language has been implemented; there is a lot of room for improvement. There are a couple of comparatively simple features that can be added immediately, but few of them make the language any more powerful. Such changes are for the most part larger in nature, requiring more work, but they are required for the language to become viable.

    \section{Simple changes}
    
    	\subsection{Operator precedence resolution}
    	
    	The most important change at the moment is probably the resolution of operator precedence. Having to manually define precedence using parentheses is inconvenient at best and downright ridiculous in the case of function calls; having to write
		\begin{perseuslisting}
(myFunction()) + 1
		\end{perseuslisting}
		instead of
		\begin{perseuslisting}
myFunction() + 1
		\end{perseuslisting}
		is not acceptable in any way.
		
		\subsection{Variable assignments}
		
		There is also currently no way of changing a variable's value; all variables are effectively immutable. To enable usage of iterative algorithms assignment is necessary, and adding it is fairly straightforward, since determining a variable's location in memory has already been solved for usage of variables in expressions.
		
		\subsection{Tail recursion}
		
		Optimizing tail recursion calls to simply jump back to the beginning of the function is mostly a matter of recognizing them, in which case slightly different code is generated. Not a major change.
		
		\subsection{Better errors}
		
		The syntax tree is not sufficiently annotated with file locations to always get useful errors, but it could and should be.
		
		\subsection{Cleaner API}
		
		The header files are not currently sufficiently separated into interface and implementation; it should be made clearer to the user what they are supposed to include by having those headers in a separate directory.
	
	\section{Complex changes}
		
		\subsection{Upgrade to Boost.Spirit 3}
		
		Version 2 of Boost.Spirit is used, which was the latest stable version when development started. The next version has since been released, with potential improvements in compile time, speed and ease of use. An upgrade should be considered while the code base is still relatively small, before adding many new features, because the new version is incompatible with the current one due to changed syntax.
		
		\subsection{New language features}
		
		Perseus still lacks many features, which need to be added in the future. These include modules, so the code can be separated into smaller pieces; a proper type system that lets the user define custom types; some form of dynamic memory management, on which strings depend; first class functions with closures; coroutines; and the persistence that is so central to the language.
