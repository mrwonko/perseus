% Lösung bzgl. Zielsetzung -- Bezug zu methodischem Teil herstellen

% (Ist-Analyse)
\chapter{State of the art}
        
    % immer erwähnen, was man nutzt, und nie nur das
        
	\section{Common Compiler Generators}
    	
		Lexers and parsers are rarely hand-written any more, since there are plenty of tools to generate them using formal definitions. Let's look at some common free and open source examples.
		
		\subsection{flex}
		
			flex\cite{flex} generates lexers in C from a definition file describing the tokens using regular expressions and code to be executed upon their recognition, for example suspending scanning and returning a token. The generated C source code is then compiled to get an executable lexer.
			
			%TODO is one of the oldest (?)
		
		\subsection{bison}
			
			bison\cite{bison} generates LALR and GLR Parsers in C, C++ and Java from a definition file describing the context-free grammar to be accepted. The generated source code is then compiled to get an executable parser.
		
		\subsection{Boost.Spirit}
			
			Boost.Spirit\cite{spirit} is a C++ parser and lexer library. (It also has a module for generator definitions, but that is of no interest here.) It's different from flex and bison (and most other compiler generators) in that it doesn't have a separate generation step; the definitions are made in standard C++.
			
			Boost.Spirit.Lex, the lexer component, lets you define the tokens using strings containing regular expressions. These are parsed and used to generate a deterministic finite automaton at run time, which has the downside that the computations will be repeated at each execution and syntactic errors in the regular expressions can't be detected during compilation. To offset this there's the option to generate equivalent static C++ source code for the calculated automaton on execution, which can then be used in place of the run time version for improved performance. Besides requiring no external tools for compilation it's also very easy to integrate with Boost.Spirit.Qi.
			
			Boost.Spirit.Qi is the parser component. Making heavy use of templates it allows for the definition of the grammar using overloaded operators, creating a recursive descent parser. Instead of calculating a parsing table it uses backtracking, removing the need for a separate tool prior to compilation. It avoids ambiguity through its operator definitions: An alternative $a|b$ is defined as ``if $a$ matches, use that; only try $b$ if it does not,'' while repetitions (including optional symbols) are greedy, matching as much as possible.

    \section{Common Virtual Machines}
        % Stand der Technik, insb. bzgl. VMs / Einordnung
        
        %\subsection{Java Virtual Machine}
        
        \subsection{LLVM}
        
        \subsection{node.js}
        
        % auch inhärent singlethreaded
        
        \subsection{Weitere?}
        
        Lua VM, C\# VM (CLR - Common Language Runtime, for CIL - Common Intermediate Language), LLVM, CPython, ...?

% Anforderungsanalyse / Requirements
\chapter{Requirements}

	%TODO where does this go? requirements? 
	%Native machine code would require porting work for each new platform. By using a virtual machine, any platform that's capable of running it is supported. My virtual machine requirements are mainly support for coroutines and stack inspection/unwinding, so coroutines can be serialized and aborted properly, and the ability to embed it in C++.
	
	% LLVM: no coroutines, no stack inspection(?)
	% JVM/CLR: garbage collected
	% maybe use a table?

    \section{Target Language}
    
        \subsection{Integral and boolean types}
    
        \subsection{Arithmetic Expressions}
        
            Literals
            
            Operator precedence
            
            Can't mix left \& right of same precedence
            
            Can't mix non-associative of same precedence ($a==b==c$)
        
        \subsection{Variables}
            
            no assignments yet
        
        \subsection{Functions}
        
            with parameters, importantly
        
        \subsection{Conditional Expressions}
        
        \subsection{Comments}
        
        \subsection{Future features}
            
            \subsubsection{Persistence}
                
            \subsubsection{Custom operators}
                
                so precedence can't be inherent in the grammar
                
            \subsubsection{Native functions}
                
            \subsubsection{Pointers \& Dynamic Memory}
                
                including function pointers
                
                e.g. used for strings
                
            \subsubsection{Coroutines}
            	
            	yield etc.
            
            \subsubsection{Tail Recursion}
            
    
    \section{Compiler}
        
        \subsection{Errors}
            
            include file location
            
        \subsection{UTF-8 string literals}
            
        \subsection{Probably more...}
            
            But what?
            
            Speed?
        
    \section{VM}
        
        \subsection{Fetch and Execute}
            
        \subsection{Coroutines}
            
            \subsubsection{Stack}
                
                grow arbitrarily
            
        \subsection{Memory Management}
            
            that is, the need for pointers at some point, both to stacks and heap, and how to do that nicely, considering the stack may grow, i.e. relocate
    
    % do I talk about future requirements? Like Stack Unwinding?

\chapter{Design} % TODO: better name?
% Ansatz, d.h. z.B. Architektur, Module und ihre Kommunikation
    \section{Choice of programming language}
        \subsection{Why C++?}
        \subsection{Why C++14?}
    
    \section{Choice of libraries}
        \subsection{Why Boost.Spirit?}
            no separate generation step, uses C++ templates instead (at the cost of compile time - lots of it)
            
            header-only
            
            recursive descent parser $\rightarrow$ no left recursions
            \subsubsection{Choice of version}
                why v2 and not x3?
                
                released May 15th
                
                see http://boost-spirit.com/home/2015/05/16/spirit-3-0-0/
        \subsection{Why Boost.Test?}
    
    % TODO: should I talk about coding standards at all?
    
    \section{Opcodes}
    
    
    % Namespaces - perseus / perseus::detail
    % Generally: why bytecode?
    \section{Modules}
    
        % I suppose a diagram would be useful here?
    
        \subsection{Compiler}
        
            \subsubsection{Lexer}
            Line numbers for error messages (\& Token attributes vs iterator ranges)
            
            utf-32 input preprocessing and how Spirit doesn't like that, but how it's only of interest in string literals anyway
            
            \subsubsection{Parser}
            
            \subsubsection{Code Generation}
            
        \subsection{Virtual Machines}
        
            Error handling - C++ exceptions etc.
            
            Why are pointers stack-relative?
            
            Why little metadata on stack? (except RTTI for yielding)
            
            \subsubsection{code segment}
                opcode encoding
            \subsubsection{coroutine}
            \subsubsection{stack}
            \subsubsection{processor}
        
        \subsection{Unit Tests}


% Entwicklungsanalyse
\chapter{Implementation}

    % Umsetzung wesentlicher Module, ggf. Quellcode-Ebene
    
    \section{Coming to terms with Boost}
    
        Trouble finding information in the documentation -- it's there, just hard to find.
        
        Accidental left-recursion leading to infinite loops, resulting in stack overflows.
    
    \section{Grammar definition}
    
        Sourcecode sample: this is what the definition looks like.
        
        Here's how the results are combined to create the syntax tree.
        
        Explain expectations.
        
        Operation-List in lieu of left-recursion, and how that needs to be post-processed to take care of precedences. And why those are not coded into the grammar. And how it also contains calls and indexing, making the lack of precedence resolution slightly more awkward.
    
    \section{Types}
        
        Represented as enum, only int, bool and void.
    
    \section{Function Manager}
    
        %Iterators to entries in AST, how that crashed for no apparent reason, how I'm now using pointers and unhappy about it but how it's just as legal.
        
        \subsection{Iterator Bug}
            
            is it of any interest to talk about a compiler bug I stumbled upon, couldn't quite identify (and thus did not know if it actually was a bug in the compiler and not in my code), and worked around, but that disappeared upon compiler update?
    
    \section{Code Generation}
    
        transformation from parser tree into clean tree
    
        placeholders for jump offsets
        
    \section{Code Segment}
        
        opcode encoding/decoding
        
    \section{Virtual Machine}
        
        switch-statement for opcode execution
        
        \subsection{Aggregate return bug}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Schluss: Wichtigster Teil (zusammen mit Einführung) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluating the results}
% Zusammenfassung
% What did I achieve?
% Ergebnisse zusammenfassen, bewerten bzgl. Zielsetzung, Perspektiven
% lessons learned

The goal was mostly reached: A small core of Perseus can be compiled and executed. Compared to the desired target language example (Listing~\ref{lst:target_language}), this is what the actual syntax looks like:

\begin{perseuslisting}[caption={Actual resulting language example},label={lst:result_language}]
function fib( x : i32 ) -> i32
    if x <= 1
        x
    else
    	// precedence must be explicitly defined since function calls are syntactically treated similar to binary operators and operator precedence is not resolved yet.
        ( fib( x - 1 ) ) + ( fib( x - 2 ) )

impure function main()
{
	let index : i32 = 10;
	let result = fib( index );
	print( result )
}
\end{perseuslisting}

That's pretty much on target, sans operator precedence resolution. The error messages for invalid code still leave a lot to be desired though -- they often lack information on the location of the problem. It's technically possible to include this information, and it sometimes is included already, but it was no priority during initial development, so future work in this area is required.

Meanwhile the virtual machine already has support for coroutines in anticipation for their future addition to the language. New opcodes, e.g. for unsigned integer and floating point arithmetic, are easy to add. The main challenge in extending it will probably be the addition of stack inspection and unwinding.

One of the main difficulties during development was figuring out how exactly to use certain features of Boost.Spirit, the compiler generator used. It eventually did its job, removing an additional compiler generation step from the build process as intended; and by taking advantage of C++'s powerful static type system most errors could be caught at compile time.

Due to the usage of the latest C++14 features on a preview release of the Microsoft Visual C++ Compiler, a couple of compiler bugs were encountered, but its usage was still justified in that it made writing fast, correct and elegant code noticeably easier than it would have been in C++98. The compiler has since had its full release, which fixed all the bugs that had been encountered.


\section{Resulting translation by example}

Taking listing \ref{lst:result_language} as an example, what do the steps of compilation look like? First, the lexer turns the source code into roughly the following token stream -- except whitespaces and comments are omitted in this listing for brevity, and some indentation was added to aid comprehension:

\begin{codelisting}[caption="Abridged tokens of listing \ref{lst:result_language}"]
"function", identifier(fib), "(", identifier(x), ":", identifier(i32), ")", "->", identifier(i32),
    "if", identifier(x), operator(<=), decimal literal(1),
        identifier(x),
    "else",
        "(", identifier(fib), "(", identifier(x), operator(-), decimal literal(1), ")", ")", operator(+), "(", identifier(fib), "(", identifier(x), operator(-), decimal literal(2), ")", ")"

"impure", "function", identifier(main), "(", ")",
"{"
    "let", identifier(index), ":", identifier(i32), "=", decimal literal(10), ";"
    "let", identifier(result), "=", identifier(fib), "(", identifier(index), ")", ";"
    identifier(print), "(", identifier(result), ")",
"}"
\end{codelisting}

The parser builds the syntax tree shown in figure \ref{fig:result_language_parser_tree} from these tokens. This syntax tree is then transformed in various ways: Expressions are rearranged, variable references resolved, types checked etc. The result is the transformed syntax tree shown in figure \ref{fig:result_language_transformed_tree}.

\begin{figure}
\begin{forest}
[\textit{file}
	[{fib() $\rightarrow$ i32}
		[\textit{arguments}
			[{x : i32}]
		]
		[\textit{expression}
			[\textit{operand}
				[\textit{if}
					% x <= 1
					[\textit{expression}
						[\textit{operand}
							[x]
						]
						[\textit{operations}
							[{$<=$}
								[{$1$}]
							]
						]
					]
					% x
					[\textit{expression}
						[\textit{operand}
							[x]
						]
					]
					% fib(x-1) + fib(x-2)
					[\textit{expression}
						[\textit{operand}
							% fib(x-1)
							[\textit{expression}
								[\textit{operand}
									[fib]
								]
								[\textit{operations}
									[\textit{call}
										[\textit{expression}
											[\textit{operand}
												[x]
											]
											[\textit{operations}
												[{$-$}
													[{$1$}]
												]
											]
										]
									]
								]
							]
						]
						[\textit{operations}
							[{$+$}
								% fib(x-2)
								[\textit{expression}
									[\textit{operand}
										[fib]
									]
									[\textit{operations}
										[\textit{call}
											[\textit{expression}
												[\textit{operand}
													[x]
												]
												[\textit{operations}
													[{$-$}
														[{$2$}]
													]
												]
											]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]
	[{main() $\rightarrow$ ()}
		[{[omitted for brevity]}]
	]
]
\end{forest}
\caption{Abridged syntax tree of listing \ref{lst:result_language}}
\label{fig:result_language_parser_tree}
\end{figure}

\begin{figure}
\begin{forest}
[\textit{file}
	[{fib() $\rightarrow$ i32}
		[\textit{expression}
			[\textit{if}
				[\textit{expression} : bool
					[{$<=$}
						[\textit{expression}
							[i32 var at -8]
						]
						[\textit{expression}
							[$1$]
						]
					]
				]
				[\textit{expression}
					[i32 var at -8]
				]
				[\textit{expression}
					[{$+$}
						[\textit{expression}
							[fib()
								[\textit{expression}
									[{$-$}
										[\textit{expression}
											[i32 var at -12]
										]
										[\textit{expression}
											[$1$]
										]
									]
								]
							]
						]
						[\textit{expression}
							[fib()
								[\textit{expression}
									[{$-$}
										[\textit{expression}
											[i32 var at -16]
										]
										[\textit{expression}
											[$2$]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]
	[{main() $\rightarrow$ ()}
		[{[omitted for brevity]}]
	]
]
\end{forest}
\caption{Abridged transformed syntax tree of listing \ref{lst:result_language}}
\label{fig:result_language_transformed_tree}
\end{figure}

%TODO byte code

\chapter{Future prospects}
% Ausblick
%*  [Future plans/possibilities]

As mentioned only a very simple core of the language has been implemented; there is a lot of room for improvement. There are a couple of comparatively simple features that can be added immediately, but few of them make the language any more powerful. Such changes are for the most part larger in nature, requiring more work, but they are required for the language to become viable.

    \section{Simple additions}
    
    	\subsection{Operator precedence resolution}
    	
    	The most important change at the moment is probably the resolution of operator precedence. Having to manually define precedence using parentheses is inconvenient at best and downright ridiculous in the case of function calls; having to write
		\begin{perseuslisting}
(myFunction()) + 1
		\end{perseuslisting}
		instead of
		\begin{perseuslisting}
myFunction() + 1
		\end{perseuslisting}
		is not acceptable in any way.
		
		\subsection{Variable assignments}
		
		There is also currently no way of changing a variable's value; all variables are effectively immutable. To enable usage of iterative algorithms assignment is necessary, and adding it is fairly straightforward, since determining a variable's location in memory has already been solved for usage of variables in expressions.
		
		\subsection{Tail recursion}
		
		Optimizing tail recursion calls to simply jump back to the beginning of the function is mostly a matter of recognizing them, in which case slightly different code is generated. Not a major change.
		
		\subsection{Better errors}
		
		The syntax tree is not sufficiently annotated with file locations to always get useful errors, but it could and should be.
		
		\subsection{Cleaner API}
		
		The header files are not currently sufficiently separated into interface and implementation; it should be made clearer to the user what he is supposed to include by having those headers in a separate directory.
	
	\section{Complex changes}
		
		\subsection{Upgrade to Boost.Spirit 3}
		
		Version 2 of Boost.Spirit is used, which was the latest stable version when development started. The next version has since been released, with potential improvements in compile time, speed and ease of use. An upgrade should be considered while the code base is still relatively small, before adding many new features.
		
		\subsection{New language features}
		
		Perseus still lacks many features, which need to be added in the future. These include modules, so the code can be separated into smaller pieces; a proper type system that lets the user define custom types; some form of dynamic memory management, on which strings depend; first class functions with closures; coroutines; and the persistence that is so central to the language.
