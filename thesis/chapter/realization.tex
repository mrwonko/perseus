% Lösung bzgl. Zielsetzung -- Bezug zu methodischem Teil herstellen

% (Ist-Analyse)
\chapter{State of the art}
        
    % immer erwähnen, was man nutzt, und nie nur das
        
	\section{Common Compiler Generators}
    	
		Lexers and parsers are rarely hand-written any more, since there are plenty of tools to generate them using formal definitions. Let's look at some common free and open source examples.
		
		\subsection{flex}
		
			flex\cite{flex} generates lexers in C from a definition file describing the tokens using regular expressions and code to be executed upon their recognition, for example suspending scanning and returning a token. The generated C source code is then compiled to get an executable lexer.
			
			%TODO is one of the oldest (?)
		
		\subsection{bison}
			
			bison\cite{bison} generates LALR and GLR Parsers in C, C++ and Java from a definition file describing the context-free grammar to be accepted. The generated source code is then compiled to get an executable parser.
		
		\subsection{Boost.Spirit}
			
			Boost.Spirit\cite{spirit} is a C++ parser and lexer library. (It also has a module for generator definitions, but that is of no interest here.) It's different from flex and bison (and most other compiler generators) in that it doesn't have a separate generation step; the definitions are made in standard C++.
			
			Boost.Spirit.Lex, the lexer component, lets you define the tokens using strings containing regular expressions. These are parsed and used to generate a deterministic finite automaton at run time, which means the computations will be repeated at each execution and syntactic errors in the regular expressions can't be detected during compilation. It does have the option to generate equivalent static C++ source code for the automaton on execution, which can then be used in place of the run time version for improved performance. Besides requiring no external tools for compilation it's also very easy to integrate with Boost.Spirit.Qi.
			
			Boost.Spirit.Qi is the parser component.
			
			%TODO

    \section{Common Virtual Machines}
        % Stand der Technik, insb. bzgl. VMs / Einordnung
        
        %\subsection{Java Virtual Machine}
        
        \subsection{LLVM}
        
        \subsection{node.js}
        
        % auch inhärent singlethreaded
        
        \subsection{Weitere?}
        
        Lua VM, C\# VM (CLR - Common Language Runtime, for CIL - Common Intermediate Language), LLVM, CPython, ...?

% Anforderungsanalyse / Requirements
\chapter{Requirements}

	%TODO where does this go? requirements? 
	%Native machine code would require porting work for each new platform. By using a virtual machine, any platform that's capable of running it is supported. My virtual machine requirements are mainly support for coroutines and stack inspection/unwinding, so coroutines can be serialized and aborted properly, and the ability to embed it in C++.
	
	% LLVM: no coroutines, no stack inspection(?)
	% JVM/CLR: garbage collected
	% maybe use a table?

    \section{Target Language}
    
        \subsection{Integral and boolean types}
    
        \subsection{Arithmetic Expressions}
        
            Literals
            
            Operator precedence
            
            Can't mix left \& right of same precedence
            
            Can't mix non-associative of same precedence ($a==b==c$)
        
        \subsection{Variables}
            
            no assignments yet
        
        \subsection{Functions}
        
            with parameters, importantly
        
        \subsection{Conditional Expressions}
        
        \subsection{Comments}
        
        \subsection{Future features}
            
            \subsubsection{Persistence}
                
            \subsubsection{Custom operators}
                
                so precedence can't be inherent in the grammar
                
            \subsubsection{Native functions}
                
            \subsubsection{Pointers \& Dynamic Memory}
                
                including function pointers
                
                e.g. used for strings
                
            \subsubsection{Coroutines}
            	
            	yield etc.
            
            \subsubsection{Tail Recursion}
            
    
    \section{Compiler}
        
        \subsection{Errors}
            
            include file location
            
        \subsection{UTF-8 string literals}
            
        \subsection{Probably more...}
            
            But what?
            
            Speed?
        
    \section{VM}
        
        \subsection{Fetch and Execute}
            
        \subsection{Coroutines}
            
            \subsubsection{Stack}
                
                grow arbitrarily
            
        \subsection{Memory Management}
            
            that is, the need for pointers at some point, both to stacks and heap, and how to do that nicely, considering the stack may grow, i.e. relocate
    
    % do I talk about future requirements? Like Stack Unwinding?

\chapter{Design} % TODO: better name?
% Ansatz, d.h. z.B. Architektur, Module und ihre Kommunikation
    \section{Choice of programming language}
        \subsection{Why C++?}
        \subsection{Why C++14?}
    
    \section{Choice of libraries}
        \subsection{Why Boost.Spirit?}
            no separate generation step, uses C++ templates instead (at the cost of compile time - lots of it)
            
            header-only
            
            recursive descent parser $\rightarrow$ no left recursions
            \subsubsection{Choice of version}
                why v2 and not x3?
                
                released May 15th
                
                see http://boost-spirit.com/home/2015/05/16/spirit-3-0-0/
        \subsection{Why Boost.Test?}
    
    % TODO: should I talk about coding standards at all?
    
    \section{Opcodes}
    
    
    % Namespaces - perseus / perseus::detail
    % Generally: why bytecode?
    \section{Modules}
    
        % I suppose a diagram would be useful here?
    
        \subsection{Compiler}
        
            \subsubsection{Lexer}
            Line numbers for error messages (\& Token attributes vs iterator ranges)
            
            utf-32 input preprocessing and how Spirit doesn't like that, but how it's only of interest in string literals anyway
            
            \subsubsection{Parser}
            
            \subsubsection{Code Generation}
            
        \subsection{Virtual Machines}
        
            Error handling - C++ exceptions etc.
            
            Why are pointers stack-relative?
            
            Why little metadata on stack? (except RTTI for yielding)
            
            \subsubsection{code segment}
                opcode encoding
            \subsubsection{coroutine}
            \subsubsection{stack}
            \subsubsection{processor}
        
        \subsection{Unit Tests}


% Entwicklungsanalyse
\chapter{Implementation}

    % Umsetzung wesentlicher Module, ggf. Quellcode-Ebene
    
    \section{Coming to terms with Boost}
    
        Trouble finding information in the documentation -- it's there, just hard to find.
        
        Accidental left-recursion leading to infinite loops, resulting in stack overflows.
    
    \section{Grammar definition}
    
        Sourcecode sample: this is what the definition looks like.
        
        Here's how the results are combined to create the syntax tree.
        
        Explain expectations.
        
        Operation-List in lieu of left-recursion, and how that needs to be post-processed to take care of precedences. And why those are not coded into the grammar. And how it also contains calls and indexing, making the lack of precedence resolution slightly more awkward.
    
    \section{Types}
        
        Represented as enum, only int, bool and void.
    
    \section{Function Manager}
    
        %Iterators to entries in AST, how that crashed for no apparent reason, how I'm now using pointers and unhappy about it but how it's just as legal.
        
        \subsection{Iterator Bug}
            
            is it of any interest to talk about a compiler bug I stumbled upon, couldn't quite identify (and thus did not know if it actually was a bug in the compiler and not in my code), and worked around, but that disappeared upon compiler update?
    
    \section{Code Generation}
    
        transformation from parser tree into clean tree
    
        placeholders for jump offsets
        
    \section{Code Segment}
        
        opcode encoding/decoding
        
    \section{Virtual Machine}
        
        switch-statement for opcode execution
        
        \subsection{Aggregate return bug}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Schluss: Wichtigster Teil (zusammen mit Einführung) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evaluating the results}
% Zusammenfassung
% What did I achieve?
% Ergebnisse zusammenfassen, bewerten bzgl. Zielsetzung, Perspektiven
% lessons learned

I pretty much got where I wanted: A small core of Perseus can be compiled and executed. Let's see how close I came to my desired target language example (Listing~\ref{lst:target_language}):

\lstperseus
\begin{lstlisting}[caption={Actual resulting language example}]
function fib( x : i32 ) -> i32
    if x <= 1
        x
    else
    	// precedence must be explicitly defined since function calls are syntactically treated similar to binary operators and operator precedence is not resolved yet.
        ( fib( x - 1 ) ) + ( fib( x - 2 ) )

impure function main()
{
	let index : i32 = 10;
	let result = fib( index );
	print( result )
}
\end{lstlisting}

That's pretty much where I wanted to be, sans operator precedence resolution. The error messages for invalid code still leave a lot to be desired though -- they often lack information on the location of the problem. It's technically possible to include this information, and it sometimes is included already, but it was no priority during initial development, so future work in this area is required.

Meanwhile the virtual machine already has support for coroutines in anticipation for their future addition to the language. New opcodes, e.g. for unsigned integer and floating point arithmetic, are easy to add. The main challenge in extending it will probably be the addition of stack inspection and unwinding.

One of my main difficulties during development was figuring out how exactly to use certain features of Boost.Spirit, the compiler generator I chose. But in the end it did its job well and I'm still satisfied with it for the same reasons I initially chose it: I don't need a separate generation step thanks to the usage of C++ templates; and while getting the syntax right so it compiles was tricky, once that was done it usually worked as intended -- such are the benefits of a powerful static type system.

I also ran into some compiler bugs due to developing on the bleeding edge, using the latest C++ features on a preview release of the compiler, but I still think using modern C++ was a good idea; it made writing fast, correct and elegant code a good deal easier than C++98, and all the compiler bugs I've encountered have since been fixed.

\chapter{Future prospects}
% Ausblick
%*  [Future plans/possibilities]

As I mentioned I've only just implemented a very simple core of the language; there is a lot of room for improvement. There are a couple of comparatively simple features that can be added immediately, but few of them make the language any more powerful. Such changes are for the most part larger in nature, requiring more work, but they are required for the language to become viable.

    \section{Simple additions}
    
    	\subsection{Operator precedence resolution}
    	
    	The most important change at the moment is probably the resolution of operator precedence. Having to manually define precedence using parentheses is inconvenient at best and downright ridiculous in the case of function calls; having to write
    	\lstperseus
		\begin{lstlisting}
(myFunction()) + 1
		\end{lstlisting}
		instead of
		\begin{lstlisting}
myFunction() + 1
		\end{lstlisting}
		is not acceptable in any way.
		
		\subsection{Variable assignments}
		
		There is also currently no way of changing a variable's value; all variables are effectively immutable. To enable usage of iterative algorithms assignment is necessary, and adding it is fairly straightforward, since determining a variable's location in memory has already been solved for usage of variables in expressions.
		
		\subsection{Tail recursion}
		
		Optimizing tail recursion calls to simply jump back to the beginning of the function is mostly a matter of recognizing them, in which case slightly different code is generated. Not a major change.
		
		\subsection{Better errors}
		
		The syntax tree is not sufficiently annotated with file locations to always get useful errors, but it could and should be.
		
		\subsection{Cleaner API}
		
		The header files are not currently sufficiently separated into interface and implementation; it should be made clearer to the user what he is supposed to include by having those headers in a separate directory.
	
	\section{Complex changes}
		
		\subsection{Upgrade to Boost.Spirit 3}
		
		I'm using version 2 of Boost.Spirit, which was the latest stable version when I started developing. The next version has since been released, with potential improvements in compile time, speed and ease of use. I should consider switching to it while my code base is still relatively small, before adding many new features.
		
		\subsection{New language features}
		
		Perseus still lacks many features, which need to be added in the future. These include modules, so the code can be separated into smaller pieces; a proper type system that lets the user define custom types; some form of dynamic memory management, on which strings depend; first class functions with closures; coroutines; and the persistence that is so central to the language.
